<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Henry Chess Rankings</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js for plotting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
    <style>
        /* Use Inter font family */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for a better look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* bg-gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #718096; /* bg-gray-500 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #a0aec0; /* bg-gray-400 */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">

    <!-- Main Application Container -->
    <div id="app-container" class="p-4 sm:p-6 lg:p-8">
        <h1 class="text-4xl sm:text-5xl font-bold text-center mb-8 text-amber-400">Henry Chess Rankings</h1>
        
        <!-- Loading Indicator -->
        <div id="loading" class="text-center text-lg p-4">Loading Firebase...</div>
        
        <!-- Main Content (hidden until Firebase is ready) -->
        <main id="main-content" class="hidden max-w-6xl mx-auto space-y-8">
            
            <!-- Message Bar -->
            <div id="message-bar" class="p-3 rounded-lg text-center text-white mb-4 hidden"></div>

            <!-- Add Player Form -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg border border-gray-700">
                <h2 class="text-3xl font-semibold text-amber-300 mb-4 text-center">Add New Player</h2>
                <form id="add-player-form" class="flex flex-col sm:flex-row gap-4">
                    <input type="text" id="new-player-name" placeholder="Player Name" class="flex-grow p-3 rounded-md bg-gray-700 text-white border border-gray-600 focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                    <button type="submit" class="bg-amber-600 hover:bg-amber-700 text-white font-bold py-3 px-6 rounded-md transition duration-300 ease-in-out transform hover:scale-105 shadow-lg">Add Player</button>
                </form>
            </div>

            <!-- Record Match Form -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg border border-gray-700">
                <h2 class="text-3xl font-semibold text-amber-300 mb-4 text-center">Record Match</h2>
                <form id="record-match-form" class="space-y-4">
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div>
                            <label for="white-player" class="block text-sm font-medium text-gray-300 mb-1">White:</label>
                            <select id="white-player" class="w-full p-3 rounded-md bg-gray-700 text-white border border-gray-600 focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                                <option value="">Select White Player</option>
                            </select>
                        </div>
                        <div>
                            <label for="black-player" class="block text-sm font-medium text-gray-300 mb-1">Black:</label>
                            <select id="black-player" class="w-full p-3 rounded-md bg-gray-700 text-white border border-gray-600 focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                                <option value="">Select Black Player</option>
                            </select>
                        </div>
                    </div>
                    <div>
                        <label for="winner" class="block text-sm font-medium text-gray-300 mb-1">Outcome:</label>
                        <select id="winner" class="w-full p-3 rounded-md bg-gray-700 text-white border border-gray-600 focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                            <option value="">Select Outcome</option>
                        </select>
                    </div>
                    <button type="submit" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-bold py-3 px-6 rounded-md transition duration-300 ease-in-out transform hover:scale-105 shadow-lg">Record Match</button>
                </form>
            </div>

            <!-- Leaderboard Table -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg border border-gray-700">
                <h2 class="text-3xl font-semibold text-amber-300 mb-4 text-center">Leaderboard</h2>
                <div class="mb-4">
                    <input type="text" id="search-player" placeholder="Search player by name..." class="w-full p-3 rounded-md bg-gray-700 text-white border border-gray-600 focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                </div>
                <div id="leaderboard-container" class="overflow-x-auto">
                    <!-- Table will be rendered here by JavaScript -->
                </div>
            </div>

            <!-- Rank History Chart -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg border border-gray-700">
                <h2 class="text-3xl font-semibold text-amber-300 mb-4 text-center">Rank History</h2>
                <div id="player-filter-container" class="mb-4"></div>
                <div class="flex flex-col sm:flex-row gap-4 mb-4">
                    <div class="flex-1">
                        <label for="start-date" class="block text-sm font-medium text-gray-300 mb-1">Start Date:</label>
                        <input type="date" id="start-date" class="w-full p-3 rounded-md bg-gray-700 text-white border border-gray-600 focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                    </div>
                    <div class="flex-1">
                        <label for="end-date" class="block text-sm font-medium text-gray-300 mb-1">End Date:</label>
                        <input type="date" id="end-date" class="w-full p-3 rounded-md bg-gray-700 text-white border border-gray-600 focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                    </div>
                </div>
                <div id="chart-container" style="height: 500px;">
                    <canvas id="rank-history-chart"></canvas>
                    <p id="chart-placeholder" class="text-center text-gray-400">No match history yet. Record some matches to see the graph!</p>
                </div>
            </div>

            <!-- Ranking Rules -->
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg border border-gray-700 mt-8">
                <h2 class="text-3xl font-semibold text-amber-300 mb-4 text-center">Ranking Rules</h2>
                <div class="space-y-2 text-gray-300">
                    <div><span class="font-bold text-amber-200">1)</span> To leapfrog a higher-ranked player, you must defeat them twice in a row. Draws do not reset your winning streak against that player.</div>
                    <div><span class="font-bold text-amber-200">2)</span> All chess games count. The time controls of a game don't matter.</div>
                    <div><span class="font-bold text-amber-200">3)</span> Any new player goes straight to the top of the rankings.</div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modal Dialog -->
    <div id="modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4 hidden">
        <div id="modal-content" class="bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm w-full border border-gray-700">
            <!-- Modal content will be injected here -->
        </div>
    </div>

    <!-- Firebase SDK and Application Logic -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // If you need analytics, import it here:
        // import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

        // --- GLOBAL STATE AND CONFIG ---
        let db, auth, userId;
        let players = [];
        let rankHistory = [];
        let rankChart = null; // To hold the Chart.js instance
        let selectedPlayersForChart = [];

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const playersCollectionPath = `/artifacts/${appId}/public/data/players`;
        const rankHistoryCollectionPath = `/artifacts/${appId}/public/data/rankHistory`;

        // --- UI ELEMENT REFERENCES ---
        const loadingEl = document.getElementById('loading');
        const mainContentEl = document.getElementById('main-content');
        const messageBarEl = document.getElementById('message-bar');
        const leaderboardContainerEl = document.getElementById('leaderboard-container');
        const searchPlayerInput = document.getElementById('search-player');
        
        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            // --- IMPORTANT ---
            // When running this file outside of the Canvas environment,
            // you must replace these placeholder values with your own
            // Firebase project's configuration.
            // This is the placeholder configuration that will be used if __firebase_config is not defined.
            // It should be replaced with your actual Firebase config if you run this outside the Canvas.
            const firebaseConfigPlaceholder = {

			  apiKey: "AIzaSyD6mh__50PPV-WTMVitcl3iEyArgw6HpmI",

			  authDomain: "henry-chess-rankings.firebaseapp.com",

			  projectId: "henry-chess-rankings",

			  storageBucket: "henry-chess-rankings.firebasestorage.app",

			  messagingSenderId: "572969866716",

			  appId: "1:572969866716:web:93d811059e3b74af2ceb19",

			  measurementId: "G-ZBTZ062688"

			};

            // This is the correct and only declaration of firebaseConfig
            const firebaseConfig = typeof __firebase_config !== 'undefined'
                ? JSON.parse(__firebase_config)
                : firebaseConfigPlaceholder;

            // Check if the user needs to add their Firebase config
            if (firebaseConfig.projectId === "YOUR_PROJECT_ID") {
                loadingEl.innerHTML = `
                    <div class="text-red-400 text-center p-4 bg-red-900 rounded-lg border border-red-700">
                        <strong class="font-bold text-lg block">Configuration Needed</strong>
                        <p class="mt-2">Please open this HTML file in a text editor and replace the placeholder Firebase configuration in the &lt;script&gt; tag with your own project's credentials to connect to the database.</p>
                    </div>`;
                return; // Stop initialization
            }

            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                // If you need analytics, uncomment and initialize here:
                // const analytics = getAnalytics(app);

                // Listen for authentication state changes
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        initializeAppState();
                    } else {
                        try {
                            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                                await signInWithCustomToken(auth, __initial_auth_token);
                            } else {
                                await signInAnonymously(auth);
                            }
                            // After sign-in, the onAuthStateChanged listener will be triggered again
                            // with the user object, and initializeAppState will be called then.
                        } catch (error) {
                            console.error("Error signing in:", error);
                            showMessage("Error signing in.", 'error');
                        }
                    }
                });
            } catch (error) {
                console.error("Failed to initialize Firebase:", error);
                loadingEl.textContent = `Failed to initialize Firebase: ${error.message}`;
            }
        });

        function initializeAppState() {
            loadingEl.style.display = 'none';
            mainContentEl.style.display = 'block';
            setupEventListeners();
            listenForPlayerUpdates();
            listenForRankHistoryUpdates();
            // Display the user ID for debugging/multi-user identification
            const userIdDisplay = document.createElement('p');
            userIdDisplay.className = 'text-center text-sm text-gray-400 mt-4';
            userIdDisplay.textContent = `User ID: ${userId}`;
            document.getElementById('app-container').appendChild(userIdDisplay);
        }

        // --- REAL-TIME DATA LISTENERS ---
        function listenForPlayerUpdates() {
            const playersQuery = query(collection(db, playersCollectionPath));
            onSnapshot(playersQuery, (snapshot) => {
                players = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                players.sort((a, b) => a.rank - b.rank);
                renderLeaderboard();
                updatePlayerDropdowns();
                renderPlayerFilterButtons();
                renderRankHistoryChart();
            }, (error) => {
                console.error("Error fetching players:", error);
                showMessage("Error loading players.", 'error');
            });
        }

        function listenForRankHistoryUpdates() {
            const rankHistoryQuery = query(collection(db, rankHistoryCollectionPath));
            onSnapshot(rankHistoryQuery, (snapshot) => {
                rankHistory = snapshot.docs.map(doc => {
                    const data = doc.data();
                    // Ensure timestamp is a Date object
                    data.timestamp = data.timestamp.toDate ? data.timestamp.toDate() : new Date(data.timestamp);
                    return { id: doc.id, ...data };
                });
                rankHistory.sort((a, b) => a.timestamp - b.timestamp);
                renderRankHistoryChart();
            }, (error) => {
                console.error("Error fetching rank history:", error);
                showMessage("Error loading rank history.", 'error');
            });
        }

        // --- RENDERING FUNCTIONS ---
        function renderLeaderboard() {
            const searchTerm = searchPlayerInput.value.toLowerCase();
            const filteredPlayers = players.filter(p => p.name.toLowerCase().includes(searchTerm));

            if (filteredPlayers.length === 0) {
                leaderboardContainerEl.innerHTML = `<p class="text-center text-gray-400">No players yet or no players match your search. Add some players to get started!</p>`;
                return;
            }

            const table = `
                <table class="min-w-full divide-y divide-gray-700">
                    <thead class="bg-gray-700">
                        <tr>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider rounded-tl-lg">Rank</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Player Name</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Wins</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Losses</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Draws</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Win %</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">White Win %</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Black Win %</th>
                            <th class="px-4 py-3 text-right text-xs font-medium text-gray-300 uppercase tracking-wider rounded-tr-lg">Actions</th>
                        </tr>
                    </thead>
                    <tbody class="bg-gray-800 divide-y divide-gray-700">
                        ${filteredPlayers.map(player => {
                            const totalGames = player.wins + player.losses + player.draws;
                            const overallWinRate = totalGames > 0 ? ((player.wins / totalGames) * 100).toFixed(2) : '0.00';
                            const totalGamesAsWhite = (player.winsAsWhite || 0) + (player.lossesAsWhite || 0) + (player.drawsAsWhite || 0);
                            const whiteWinRate = totalGamesAsWhite > 0 ? (((player.winsAsWhite || 0) / totalGamesAsWhite) * 100).toFixed(2) : '0.00';
                            const totalGamesAsBlack = (player.winsAsBlack || 0) + (player.lossesAsBlack || 0) + (player.drawsAsBlack || 0);
                            const blackWinRate = totalGamesAsBlack > 0 ? (((player.winsAsBlack || 0) / totalGamesAsBlack) * 100).toFixed(2) : '0.00';

                            return `
                                <tr class="hover:bg-gray-700 transition duration-150 ease-in-out">
                                    <td class="px-4 py-4 whitespace-nowrap text-sm font-medium text-gray-200">${player.rank}</td>
                                    <td class="px-4 py-4 whitespace-nowrap text-sm text-gray-300">${player.name}</td>
                                    <td class="px-4 py-4 whitespace-nowrap text-sm text-gray-300">${player.wins}</td>
                                    <td class="px-4 py-4 whitespace-nowrap text-sm text-gray-300">${player.losses}</td>
                                    <td class="px-4 py-4 whitespace-nowrap text-sm text-gray-300">${player.draws}</td>
                                    <td class="px-4 py-4 whitespace-nowrap text-sm text-gray-300">${overallWinRate}%</td>
                                    <td class="px-4 py-4 whitespace-nowrap text-sm text-gray-300">${whiteWinRate}%</td>
                                    <td class="px-4 py-4 whitespace-nowrap text-sm text-gray-300">${blackWinRate}%</td>
                                    <td class="px-4 py-4 whitespace-nowrap text-right text-sm font-medium">
                                        <button data-action="edit" data-player-id="${player.id}" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-md transition duration-300 ease-in-out transform hover:scale-105">Edit</button>
                                        <button data-action="remove" data-player-id="${player.id}" class="ml-2 bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-md transition duration-300 ease-in-out transform hover:scale-105">Remove</button>
                                    </td>
                                </tr>`;
                        }).join('')}
                    </tbody>
                </table>`;
            leaderboardContainerEl.innerHTML = table;
        }

        function updatePlayerDropdowns() {
            const whitePlayerSelect = document.getElementById('white-player');
            const blackPlayerSelect = document.getElementById('black-player');
            
            const options = players.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
            
            whitePlayerSelect.innerHTML = `<option value="">Select White Player</option>${options}`;
            blackPlayerSelect.innerHTML = `<option value="">Select Black Player</option>${options}`;

            updateWinnerDropdown();
        }
        
        function updateWinnerDropdown() {
            const winnerSelect = document.getElementById('winner');
            const whitePlayerId = document.getElementById('white-player').value;
            const blackPlayerId = document.getElementById('black-player').value;

            let options = '<option value="">Select Outcome</option>';
            if (whitePlayerId) {
                const whitePlayer = players.find(p => p.id === whitePlayerId);
                options += `<option value="${whitePlayerId}">${whitePlayer.name} (White) Wins</option>`;
            }
            if (blackPlayerId) {
                const blackPlayer = players.find(p => p.id === blackPlayerId);
                options += `<option value="${blackPlayerId}">${blackPlayer.name} (Black) Wins</option>`;
            }
            options += '<option value="draw">Draw</option>';
            winnerSelect.innerHTML = options;
        }

        function renderPlayerFilterButtons() {
            const container = document.getElementById('player-filter-container');
            const allPlayerNames = players.map(p => p.name);
            if (allPlayerNames.length === 0) {
                container.innerHTML = '';
                return;
            }

            let buttonsHTML = `<label class="block text-sm font-medium text-gray-300 mb-2">Filter Players:</label>
                               <div class="flex flex-wrap gap-2">`;
            allPlayerNames.forEach(name => {
                const isSelected = selectedPlayersForChart.includes(name);
                buttonsHTML += `<button data-player-name="${name}" class="player-filter-btn px-3 py-1 rounded-full text-sm font-semibold transition duration-200 ease-in-out ${isSelected ? 'bg-amber-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}">${name}</button>`;
            });

            if (selectedPlayersForChart.length > 0) {
                buttonsHTML += `<button id="clear-player-filter-btn" class="px-3 py-1 rounded-full text-sm font-semibold bg-red-600 text-white hover:bg-red-700 transition duration-200 ease-in-out">Clear Filter</button>`;
            }
            buttonsHTML += `</div>`;
            container.innerHTML = buttonsHTML;
        }

        function renderRankHistoryChart() {
            const canvas = document.getElementById('rank-history-chart');
            const placeholder = document.getElementById('chart-placeholder');
            const ctx = canvas.getContext('2d');

            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;

            let filteredHistory = rankHistory;
            if (startDate) {
                const startOfDay = new Date(startDate);
                startOfDay.setHours(0, 0, 0, 0);
                filteredHistory = filteredHistory.filter(snapshot => snapshot.timestamp.getTime() >= startOfDay.getTime());
            }
            if (endDate) {
                const endOfDay = new Date(endDate);
                endOfDay.setHours(23, 59, 59, 999);
                filteredHistory = filteredHistory.filter(snapshot => snapshot.timestamp.getTime() <= endOfDay.getTime());
            }

            if (filteredHistory.length === 0) {
                canvas.style.display = 'none';
                placeholder.style.display = 'block';
                if(rankChart) rankChart.destroy();
                return;
            }
            
            canvas.style.display = 'block';
            placeholder.style.display = 'none';

            const chartData = filteredHistory.map(snapshot => {
                const dataPoint = { x: snapshot.timestamp };
                snapshot.rankings.forEach(ranking => {
                    dataPoint[ranking.playerName] = ranking.rank;
                });
                return dataPoint;
            });

            const allPlayerNames = players.map(p => p.name);
            const playersToDisplay = selectedPlayersForChart.length > 0 ? selectedPlayersForChart : allPlayerNames;

            const datasets = playersToDisplay.map((name, index) => {
                const color = `hsl(${index * 137 % 360}, 70%, 60%)`;
                return {
                    label: name,
                    data: chartData.map(d => ({ x: d.x, y: d[name] })).filter(p => p.y !== undefined), // Filter out points where player didn't exist
                    borderColor: color,
                    backgroundColor: color,
                    tension: 0.1,
                    spanGaps: true, // Connect lines across gaps
                };
            });
            
            const maxRank = players.length > 0 ? Math.max(...players.map(p => p.rank)) : 1;

            if (rankChart) {
                rankChart.destroy();
            }

            rankChart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                // FIX: Add minUnit to ensure ticks are drawn at least at this interval
                                minUnit: 'day', 
                                tooltipFormat: 'PPpp', // date-fns format
                                displayFormats: {
                                    day: 'MMM d, yyyy'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                color: '#cbd5e0'
                            },
                            grid: { color: '#4a5568' },
                            ticks: {
                                color: '#cbd5e0',
                                source: 'auto',
                                major: {
                                    enabled: true
                                },
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Rank',
                                color: '#cbd5e0'
                            },
                            reverse: true,
                            min: 1,
                            max: maxRank + 1,
                            grid: { color: '#4a5568' },
                            ticks: { 
                                color: '#cbd5e0',
                                stepSize: 1
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#cbd5e0'
                            }
                        },
                        tooltip: {
                            backgroundColor: '#2d3748',
                            titleColor: '#a0aec0',
                            bodyColor: '#e2e8f0',
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: Rank ${context.parsed.y}`;
                                }
                            }
                        }
                    }
                }
            });
        }


        // --- EVENT HANDLERS & LOGIC ---
        function setupEventListeners() {
            // Forms
            document.getElementById('add-player-form').addEventListener('submit', handleAddPlayer);
            document.getElementById('record-match-form').addEventListener('submit', handleRecordMatch);

            // Player dropdowns
            document.getElementById('white-player').addEventListener('change', updateWinnerDropdown);
            document.getElementById('black-player').addEventListener('change', updateWinnerDropdown);

            // Leaderboard actions (delegated)
            leaderboardContainerEl.addEventListener('click', (e) => {
                const target = e.target.closest('button');
                if (!target) return;
                
                const action = target.dataset.action;
                const playerId = target.dataset.playerId;

                if (action === 'edit') handleEditPlayer(playerId);
                if (action === 'remove') handleRemovePlayer(playerId);
            });

            // Search
            searchPlayerInput.addEventListener('input', renderLeaderboard);

            // Chart Filters
            document.getElementById('player-filter-container').addEventListener('click', (e) => {
                if (e.target.classList.contains('player-filter-btn')) {
                    const playerName = e.target.dataset.playerName;
                    if (selectedPlayersForChart.includes(playerName)) {
                        selectedPlayersForChart = selectedPlayersForChart.filter(name => name !== playerName);
                    } else {
                        selectedPlayersForChart.push(playerName);
                    }
                    renderPlayerFilterButtons();
                    renderRankHistoryChart();
                } else if (e.target.id === 'clear-player-filter-btn') {
                    selectedPlayersForChart = [];
                    renderPlayerFilterButtons();
                    renderRankHistoryChart();
                }
            });
            document.getElementById('start-date').addEventListener('change', renderRankHistoryChart);
            document.getElementById('end-date').addEventListener('change', renderRankHistoryChart);
        }

        async function handleAddPlayer(e) {
            e.preventDefault();
            const playerNameInput = document.getElementById('new-player-name');
            const playerName = playerNameInput.value.trim();
            if (!playerName) {
                showModal("Player name cannot be empty.");
                return;
            }

            try {
                const existingPlayersQuery = query(collection(db, playersCollectionPath), where("name", "==", playerName));
                const existingPlayersSnapshot = await getDocs(existingPlayersQuery);
                if (!existingPlayersSnapshot.empty) {
                    showModal(`A player with the name "${playerName}" already exists.`);
                    return;
                }

                const batch = writeBatch(db);
                const currentPlayersSnapshot = await getDocs(collection(db, playersCollectionPath));
                currentPlayersSnapshot.docs.forEach(docSnap => {
                    const playerRef = doc(db, playersCollectionPath, docSnap.id);
                    batch.update(playerRef, { rank: docSnap.data().rank + 1 });
                });

                const newPlayerRef = doc(collection(db, playersCollectionPath));
                batch.set(newPlayerRef, {
                    name: playerName, rank: 1, wins: 0, losses: 0, draws: 0,
                    winsAsWhite: 0, lossesAsWhite: 0, drawsAsWhite: 0,
                    winsAsBlack: 0, lossesAsBlack: 0, drawsAsBlack: 0,
                    recentMatchHistory: {},
                });

                await batch.commit();

                // Record rank history after adding player
                const updatedPlayersSnapshot = await getDocs(query(collection(db, playersCollectionPath)));
                const updatedPlayers = updatedPlayersSnapshot.docs.map(d => ({id: d.id, ...d.data()}));
                const currentRankings = updatedPlayers.map(p => ({ playerId: p.id, playerName: p.name, rank: p.rank }));
                await addDoc(collection(db, rankHistoryCollectionPath), {
                    timestamp: new Date(),
                    rankings: currentRankings,
                });

                playerNameInput.value = '';
                showMessage(`${playerName} added successfully at Rank 1!`, 'success');
            } catch (error) {
                console.error("Error adding player:", error);
                showMessage("Error adding player.", 'error');
            }
        }
        
        function handleEditPlayer(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;

            const content = `
                <h3 class="text-2xl font-semibold text-amber-300 mb-4 text-center">Edit Player Name</h3>
                <form id="edit-player-form" class="space-y-4">
                    <input type="text" id="edit-player-name-input" value="${player.name}" class="w-full p-3 rounded-md bg-gray-700 text-white border border-gray-600 focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                    <div class="flex justify-end space-x-4">
                        <button type="button" id="cancel-edit-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md">Cancel</button>
                        <button type="submit" class="bg-amber-600 hover:bg-amber-700 text-white font-bold py-2 px-4 rounded-md">Save Changes</button>
                    </div>
                </form>
            `;
            showModal(content, false);

            document.getElementById('edit-player-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const newName = document.getElementById('edit-player-name-input').value.trim();
                if (!newName) {
                    showModal("Player name cannot be empty."); // Changed from alert to showModal
                    return;
                }
                try {
                    await updateDoc(doc(db, playersCollectionPath, playerId), { name: newName });
                    showMessage(`Player name updated to ${newName}!`, 'success');
                    closeModal();
                } catch (error) {
                    console.error("Error updating player name:", error);
                    showMessage("Error updating player name.", 'error');
                    closeModal();
                }
            });
            document.getElementById('cancel-edit-btn').addEventListener('click', closeModal);
        }

        function handleRemovePlayer(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;

            const content = `
                <div class="text-center">
                    <p class="mb-4">Are you sure you want to remove <span class="font-bold">${player.name}</span>? This action cannot be undone.</p>
                    <div class="flex justify-center space-x-4">
                        <button id="confirm-remove-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md">Yes, Remove</button>
                        <button id="cancel-remove-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md">Cancel</button>
                    </div>
                </div>
            `;
            showModal(content, false);

            document.getElementById('confirm-remove-btn').addEventListener('click', async () => {
                try {
                    await deleteDoc(doc(db, playersCollectionPath, playerId));
                    showMessage(`${player.name} removed successfully!`, 'success');
                    closeModal();
                } catch (error) {
                    console.error("Error removing player:", error);
                    showMessage(`Error removing ${player.name}.`, 'error');
                    closeModal();
                }
            });
            document.getElementById('cancel-remove-btn').addEventListener('click', closeModal);
        }

        async function handleRecordMatch(e) {
            e.preventDefault();
            const whitePlayerId = document.getElementById('white-player').value;
            const blackPlayerId = document.getElementById('black-player').value;
            const winnerId = document.getElementById('winner').value;

            if (!whitePlayerId || !blackPlayerId || !winnerId) {
                showModal("Please select both players and the match outcome.");
                return;
            }
            if (whitePlayerId === blackPlayerId) {
                showModal("A player cannot play against themselves.");
                return;
            }

            try {
                const whitePlayerRef = doc(db, playersCollectionPath, whitePlayerId);
                const blackPlayerRef = doc(db, playersCollectionPath, blackPlayerId);
                const whitePlayerSnap = await getDoc(whitePlayerRef);
                const blackPlayerSnap = await getDoc(blackPlayerRef);

                if (!whitePlayerSnap.exists() || !blackPlayerSnap.exists()) {
                    showMessage("One or both players not found. Please refresh.", 'error');
                    return;
                }

                let whiteData = { ...whitePlayerSnap.data() };
                let blackData = { ...blackPlayerSnap.data() };

                // Initialize stats if they don't exist
                const statFields = ['winsAsWhite', 'lossesAsWhite', 'drawsAsWhite', 'winsAsBlack', 'lossesAsBlack', 'drawsAsBlack', 'recentMatchHistory'];
                [whiteData, blackData].forEach(playerData => {
                    statFields.forEach(field => {
                        if (playerData[field] === undefined) {
                            playerData[field] = (field === 'recentMatchHistory') ? {} : 0;
                        }
                    });
                });

                let rankChanged = false;
                let messageText = "Match recorded successfully!";

                if (winnerId === 'draw') {
                    whiteData.draws++;
                    blackData.draws++;
                    whiteData.drawsAsWhite++;
                    blackData.drawsAsBlack++;
                    
                    // Update history for white player, preserving the streak
                    const whiteHistory = whiteData.recentMatchHistory[blackPlayerId] || { streak: 0 };
                    whiteHistory.lastOutcome = 'draw';
                    whiteData.recentMatchHistory[blackPlayerId] = whiteHistory;

                    // Update history for black player, preserving the streak
                    const blackHistory = blackData.recentMatchHistory[whitePlayerId] || { streak: 0 };
                    blackHistory.lastOutcome = 'draw';
                    blackData.recentMatchHistory[whitePlayerId] = blackHistory;

                } else {
                    const winnerData = winnerId === whitePlayerId ? whiteData : blackData;
                    const loserData = winnerId === whitePlayerId ? blackData : whiteData;
                    const winnerOpponentId = winnerId === whitePlayerId ? blackPlayerId : whitePlayerId;
                    const loserOpponentId = winnerId === whitePlayerId ? whitePlayerId : blackPlayerId;

                    winnerData.wins++;
                    loserData.losses++;
                    
                    if (winnerId === whitePlayerId) { // White won
                        whiteData.winsAsWhite++;
                        blackData.lossesAsBlack++;
                    } else { // Black won
                        blackData.winsAsBlack++;
                        whiteData.lossesAsWhite++;
                    }

                    const winnerHistory = winnerData.recentMatchHistory[winnerOpponentId] || { streak: 0, lastOutcome: '' };
                    // A winning streak is only broken by a loss. A draw does not break the streak.
                    if (winnerHistory.lastOutcome === 'loss') {
                        winnerHistory.streak = 1; // Start a new streak
                    } else {
                        winnerHistory.streak += 1; // Continue streak from a win or a draw
                    }
                    winnerHistory.lastOutcome = 'win';
                    winnerData.recentMatchHistory[winnerOpponentId] = winnerHistory;
                    
                    const loserHistory = loserData.recentMatchHistory[loserOpponentId] || { streak: 0 };
                    loserHistory.streak = 0; // Loser's winning streak against this opponent is broken
                    loserHistory.lastOutcome = 'loss';
                    loserData.recentMatchHistory[loserOpponentId] = loserHistory;

                    if (winnerHistory.streak === 2 && winnerData.rank > loserData.rank) {
                        [winnerData.rank, loserData.rank] = [loserData.rank, winnerData.rank]; // Swap ranks
                        rankChanged = true;
                        messageText = `${winnerData.name} beat ${loserData.name} twice and leapfrogged them!`;
                    }
                }

                const batch = writeBatch(db);
                batch.update(whitePlayerRef, whiteData);
                batch.update(blackPlayerRef, blackData);
                await batch.commit();

                // Record rank history snapshot
                const currentPlayers = players.map(p => {
                    if (p.id === whitePlayerId) return { ...p, ...whiteData };
                    if (p.id === blackPlayerId) return { ...p, ...blackData };
                    return p;
                });
                const currentRankings = currentPlayers.map(p => ({ playerId: p.id, playerName: p.name, rank: p.rank }));
                await addDoc(collection(db, rankHistoryCollectionPath), {
                    timestamp: new Date(),
                    rankings: currentRankings,
                });

                showMessage(messageText, 'success');
                document.getElementById('record-match-form').reset();
                updateWinnerDropdown();

            } catch (error) {
                console.error("Error recording match:", error);
                showMessage("Error recording match.", 'error');
            }
        }

        // --- UTILITY FUNCTIONS ---
        function showMessage(msg, type = 'info') {
            messageBarEl.textContent = msg;
            messageBarEl.className = `p-3 rounded-lg text-center text-white mb-4 ${type === 'error' ? 'bg-red-700' : 'bg-blue-700'}`;
            messageBarEl.style.display = 'block';
            setTimeout(() => {
                messageBarEl.style.display = 'none';
            }, 5000);
        }

        function showModal(content, isSimpleText = true) {
            const modal = document.getElementById('modal');
            const modalContent = document.getElementById('modal-content');

            if (isSimpleText) {
                modalContent.innerHTML = `
                    <p class="text-white text-center mb-4">${content}</p>
                    <button id="modal-ok-btn" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-bold py-2 px-4 rounded-md">OK</button>
                `;
                document.getElementById('modal-ok-btn').addEventListener('click', closeModal);
            } else {
                modalContent.innerHTML = content;
            }
            modal.style.display = 'flex';
        }

        function closeModal() {
            const modal = document.getElementById('modal');
            modal.style.display = 'none';
            document.getElementById('modal-content').innerHTML = ''; // Clear content
        }

    </script>
</body>
</html>
